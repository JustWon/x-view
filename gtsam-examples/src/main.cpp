// As this is a planar SLAM example, we will use Pose2 variables (x, y, theta) to represent
// the robot positions and Point2 variables (x, y) to represent the landmark coordinates.
#include <gtsam/geometry/Pose2.h>
#include <gtsam/geometry/Point2.h>

// Each variable in the system (poses and landmarks) must be identified with a unique key.
// We can either use simple integer keys (1, 2, 3, ...) or symbols (X1, X2, L1).
// Here we will use Symbols
#include <gtsam/inference/Symbol.h>

// In GTSAM, measurement functions are represented as 'factors'. Several common factors
// have been provided with the library for solving robotics/SLAM/Bundle Adjustment problems.
// Here we will use a RangeBearing factor for the range-bearing measurements to identified
// landmarks, and Between factors for the relative motion described by odometry measurements.
// Also, we will initialize the robot at the origin using a Prior factor.
#include <gtsam/slam/PriorFactor.h>
#include <gtsam/slam/BetweenFactor.h>

// When the factors are created, we will add them to a Factor Graph. As the factors we are using
// are nonlinear factors, we will need a Nonlinear Factor Graph.
#include <gtsam/nonlinear/NonlinearFactorGraph.h>

// Finally, once all of the factors have been added to our factor graph, we will want to
// solve/optimize to graph to find the best (Maximum A Posteriori) set of variable values.
// GTSAM includes several nonlinear optimizers to perform this step. Here we will use the
// common Levenberg-Marquardt solver
#include <gtsam/nonlinear/LevenbergMarquardtOptimizer.h>


// The nonlinear solvers within GTSAM are iterative solvers, meaning they linearize the
// nonlinear functions around an initial linearization point, then solve the linear system
// to update the linearization point. This happens repeatedly until the solver converges
// to a consistent set of variable values. This requires us to specify an initial guess
// for each variable, held in a Values container.
#include <gtsam/nonlinear/Values.h>


// Simulator used to generate real poses/observations plus simulated ones according to
// the noise model passed as argument
#include "Simulator.hpp"


int main(int argc, char **argv) {

    int numPoses = 10, numSteps = 2;

    Eigen::Vector2d transNoise(0.05, 0.1);
    double rotNoise(0.05);
    double rangeNoise(0.1), bearingNoise(0.05);

    const Eigen::Vector2d bound(25.0, 25.0);

    // generate synthetic path
    gtsam_example::Simulator simulator;
    simulator.setTranslationNoise(transNoise, rotNoise);
    simulator.setLandmarkDetectionNoise(rangeNoise, bearingNoise);
    simulator.simulate(numPoses, numSteps);


    // Create a factor graph
    gtsam::NonlinearFactorGraph graph;

    // generate the symbols associated to the data generated by the simulator
    std::map<int, gtsam::Symbol> poseSymbols;
    std::map<int, gtsam::Symbol> odometryEdgeSymbols;
    std::map<int, gtsam::Symbol> landmarkSymbols;
    std::map<int, gtsam::Symbol> landmarkEdgeSymbols;

    for (int i = 0; i < simulator.poses().size(); ++i) {
        poseSymbols[simulator.poses()[i].id] = gtsam::Symbol('x', i);
    }
    for (int i = 0; i < simulator.odometryEdges().size(); ++i) {
        odometryEdgeSymbols[i] = gtsam::Symbol('o', i);
    }
    for (int i = 0; i < simulator.landmarks().size(); ++i) {
        landmarkSymbols[simulator.landmarks()[i].id] = gtsam::Symbol('l', i);
    }
    for (int i = 0; i < simulator.landmarkEdges().size(); ++i) {
        landmarkEdgeSymbols[i] = gtsam::Symbol('e', i);
    }

    // Add a prior on pose x1 at its true pose (no noise) and add it to the graph
    gtsam::Pose2 prior = simulator.poses()[0].truePose; // prior mean is at origin
    gtsam::noiseModel::Diagonal::shared_ptr priorNoise = gtsam::noiseModel::Diagonal::Sigmas(Eigen::Vector3d::Zero());
    graph.emplace_shared<gtsam::PriorFactor<gtsam::Pose2> >(poseSymbols[0], prior, priorNoise);

    // Add odometry factors
    gtsam::noiseModel::Diagonal::shared_ptr odometryNoise =
            gtsam::noiseModel::Diagonal::Variances(Eigen::Vector3d(transNoise(0), transNoise(1), rotNoise));
    for (auto it = simulator.odometryEdges().begin(); it != simulator.odometryEdges().end(); ++it) {
        gtsam::Pose2 odometry = it->simulatorTransf;
        graph.emplace_shared<gtsam::BetweenFactor<gtsam::Pose2>>(poseSymbols[it->from], poseSymbols[it->to], odometry,
                                                                 odometryNoise);
    }

    // Add landmark factors
    gtsam::noiseModel::Diagonal::shared_ptr measurementNoise =
            gtsam::noiseModel::Diagonal::Variances(
                    Eigen::Vector2d(rangeNoise * rangeNoise, bearingNoise * bearingNoise));
    for (auto it = simulator.landmarkEdges().begin(); it != simulator.landmarkEdges().end(); ++it) {
        Eigen::Vector2d measurement = it->simulatorMeas;
        const double angle = std::atan2(measurement.y(), measurement.x());
        const double range = measurement.norm();
        graph.emplace_shared<gtsam::BearingRangeFactor<gtsam::Pose2, gtsam::Point2>>(poseSymbols[it->from],
                                                                                     landmarkSymbols[it->to], angle,
                                                                                     range, measurementNoise);
    }


    // Print
    graph.print("Factor Graph:\n");

    // Initial estimate of poses is the one being simulated
    gtsam::Values initialEstimate;
    for (auto it = simulator.poses().begin(); it != simulator.poses().end(); ++it) {
        initialEstimate.insert(poseSymbols[it->id], it->simulatorPose);
    }
    for (auto it = simulator.landmarks().begin(); it != simulator.landmarks().end(); ++it) {
        initialEstimate.insert(landmarkSymbols[it->id], it->simulatedPose);
    }

    // Print
    initialEstimate.print("Initial Estimate:\n");

    // Optimize using Levenberg-Marquardt optimization. The optimizer
    // accepts an optional set of configuration parameters, controlling
    // things like convergence criteria, the type of linear system solver
    // to use, and the amount of information displayed during optimization.
    // Here we will use the default set of parameters.  See the
    // documentation for the full set of parameters.
    gtsam::LevenbergMarquardtOptimizer optimizer(graph, initialEstimate);
    gtsam::Values result = optimizer.optimize();
    result.print("Final Result:\n");


    return 0;
}

